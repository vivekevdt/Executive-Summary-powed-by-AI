import { v4 as uuid } from 'uuid';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

import { convertPptToPdf, convertDocxToPdf } from '../services/pptService.js';

import {
  uploadPdf,
  generateSummaryFromPdfs
} from '../services/llmService.js';
import { sendMailWithAttachment } from '../services/mailService.js';
import { saveMetadata, getAllMetadata } from '../utils/fileUtils.js';

import { generateDocx } from '../services/generateDocx.js';
import { updateProgress, clearProgress, getProgress } from '../utils/progressStore.js';




export const generateExecutiveSummary = async (req, res) => {
  try {
    console.log("üöÄ Step 0: Request received");

    const prevPpt = req.files.previousWeek[0];
    const currPpt = req.files.currentWeek[0];
    const jobId = req.body.jobId || uuid();
    const recipientEmail = req.body.recipientEmail;
    const id = uuid();

    const validateEmails = (emails) => {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emails.split(',').every(e => emailRegex.test(e.trim()));
    };

    if (!recipientEmail || !validateEmails(recipientEmail)) {
      throw new Error("A valid recipient email address (or list of addresses) is required.");
    }

    updateProgress(jobId, 5, "Initializing analysis...");


    const prevPdf = `src/storage/generated/${id}-prev.pdf`;
    const currPdf = `src/storage/generated/${id}-curr.pdf`;
    const finalDocx = `src/storage/generatedSummary/${id}-executive-summary.docx`;

    await convertPptToPdf(prevPpt.path, prevPdf);
    updateProgress(jobId, 20, "Converting Previous Week PPT...");
    await convertPptToPdf(currPpt.path, currPdf);
    updateProgress(jobId, 40, "Converting Current Week PPT...");

    console.log("‚úÖ PDFs generated");

    // Clean up uploaded PPTs to save space
    try {
      if (fs.existsSync(prevPpt.path)) fs.unlinkSync(prevPpt.path);
      if (fs.existsSync(currPpt.path)) fs.unlinkSync(currPpt.path);
      console.log("üßπ Uploaded PPTs deleted");
    } catch (cleanupErr) {
      console.warn("‚ö†Ô∏è Failed to delete PPTs:", cleanupErr);
    }


    //  Upload PDFs to OpenAI
    const prevPdfId = await uploadPdf(prevPdf);
    updateProgress(jobId, 50, "Uploading data to AI (1/2)...");
    const currPdfId = await uploadPdf(currPdf);
    updateProgress(jobId, 60, "Uploading data to AI (2/2)...");

    console.log("‚úÖ PDFs uploaded to OpenAI");


    //  LLM reads PDFs directly
    updateProgress(jobId, 70, "AI is analyzing performance data...");
    const summaryJson = await generateSummaryFromPdfs(prevPdfId, currPdfId, 'file-QtdoRQQ8gReakjxo8sFtrH',);

    console.log("‚úÖ Executive summary generated by LLM");
    console.log("DEBUG: LLM Response Structure:", JSON.stringify(summaryJson, null, 2).substring(0, 500) + "...");

    updateProgress(jobId, 90, "Generating formal reports...");
    await generateDocx(summaryJson, finalDocx);

    // Also generate a PDF version for browser viewing
    const finalPdf = `src/storage/generatedSummary/${id}-executive-summary.pdf`;
    try {
      await convertDocxToPdf(finalDocx, finalPdf);
    } catch (pdfErr) {
      console.warn("Failed to generate PDF preview, but DOCX is ready:", pdfErr);
    }


    await sendMailWithAttachment(finalDocx, recipientEmail);
    updateProgress(jobId, 100, "Report complete and emailed!");

    const summaryJsonPath = `src/storage/generatedSummary/${id}-summary.json`;
    fs.writeFileSync(summaryJsonPath, JSON.stringify(summaryJson, null, 2));

    saveMetadata({
      fileId: id,
      millName: summaryJson.header?.mill_name || "Unknown Mill",
      week: summaryJson.header?.week || "Unknown Week",
      fileName: `${id}-executive-summary.docx`,
      filePath: `reports/download/${id}-executive-summary.docx`,
      pdfPath: `reports/download/${id}-executive-summary.pdf`,
      summaryPath: `reports/summary/${id}`,
      createdAt: new Date().toISOString()
    });



    res.json({
      success: true,
      summary: summaryJson,
      fileId: id,
      message: 'Executive summary generated successfully'
    });

    // Keep progress for a few seconds so frontend can catch the 100%
    setTimeout(() => clearProgress(jobId), 10000);

  } catch (error) {
    console.error("‚ùå Error occurred:", error);
    if (req.body.jobId) updateProgress(req.body.jobId, 0, "Error: " + error.message);
    res.status(500).json({ error: error.message });
  }
};

export const getJobStatus = async (req, res) => {
  const { jobId } = req.params;
  const status = getProgress(jobId);
  if (!status) return res.status(404).json({ error: "Job not found" });
  res.json(status);
};


export const getReportSummary = async (req, res) => {
  try {
    const { fileId } = req.params;
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    // Attempting to locate the file in the storage directory
    const summaryPath = path.resolve(__dirname, `../storage/generatedSummary/${fileId}-summary.json`);

    console.log(`üîç [DEBUG] Searching for summary: ${summaryPath}`);
    console.log(`üîç [DEBUG] File exists? ${fs.existsSync(summaryPath)}`);

    if (!fs.existsSync(summaryPath)) {
      console.warn(`‚ö†Ô∏è [WARNING] Summary file not found for ${fileId}`);
      return res.status(404).json({ error: "Structured summary not found. Try 'File View' if available." });
    }

    const summary = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
    res.status(200).json({
      success: true,
      message: "Report summary fetched successfully",
      data: summary,
    });
  } catch (error) {
    console.error("‚ùå [ERROR] getReportSummary:", error);
    res.status(500).json({ error: error.message });
  }
};



export const getAllReports = async (req, res) => {
  try {
    const reports = getAllMetadata();
    res.json(reports);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const downloadFile = async (req, res) => {
  try {
    const { filename } = req.params;
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const filePath = path.resolve(__dirname, `../storage/generatedSummary/${filename}`);

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: "File not found" });
    }

    res.download(filePath, filename);
  } catch (error) {
    console.error("‚ùå [ERROR] downloadFile:", error);
    res.status(500).json({ error: error.message });
  }
};

export const updateReport = async (req, res) => {
  try {
    const { fileId } = req.params;
    const updatedData = req.body;
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    // Paths
    const summaryPath = path.resolve(__dirname, `../storage/generatedSummary/${fileId}-summary.json`);
    const docxPath = path.resolve(__dirname, `../storage/generatedSummary/${fileId}-executive-summary.docx`);
    const pdfPath = path.resolve(__dirname, `../storage/generatedSummary/${fileId}-executive-summary.pdf`);

    if (!fs.existsSync(summaryPath)) {
      return res.status(404).json({ error: "Report not found" });
    }

    // 1. Update JSON
    console.log("Checkpoint [1/4]: Saving updated JSON summary...");
    fs.writeFileSync(summaryPath, JSON.stringify(updatedData, null, 2));

    // 2. Regenerate DOCX
    console.log("Checkpoint [2/4]: Regenerating DOCX...");

    // Check structure
    if (updatedData) {
      console.log("Checkpoint [INFO]: 'updatedData.data' found. Passing inner data to generator.");
      await generateDocx(updatedData, docxPath);
    }


    console.log("Checkpoint [3/4]: DOCX generation completed.");

    // 3. Regenerate PDF
    console.log("Checkpoint [4/4]: Regenerating PDF...");
    try {
      await convertDocxToPdf(docxPath, pdfPath);
      console.log("pdf generated successfully");
    } catch (pdfErr) {
      console.warn("Failed to regenerate PDF, but data saved:", pdfErr);
      // We continue, as saving data is primary
    }

    res.json({ success: true, message: "Report updated and regenerated successfully", data: updatedData });

  } catch (error) {
    console.error("‚ùå updateReport Error:", error);
    res.status(500).json({ error: error.message });
  }
};




